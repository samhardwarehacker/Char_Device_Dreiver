head	1.60;
access;
symbols;
locks
	root:1.60; strict;
comment	@ * @;


1.60
date	2017.07.20.17.59.36;	author root;	state Exp;
branches;
next	1.59;

1.59
date	2017.07.20.07.09.15;	author root;	state Exp;
branches;
next	1.58;

1.58
date	2017.07.20.06.55.36;	author root;	state Exp;
branches;
next	1.57;

1.57
date	2017.07.20.06.52.02;	author root;	state Exp;
branches;
next	1.56;

1.56
date	2017.07.20.06.45.27;	author root;	state Exp;
branches;
next	1.55;

1.55
date	2017.07.20.06.42.05;	author root;	state Exp;
branches;
next	1.54;

1.54
date	2017.07.20.06.41.12;	author root;	state Exp;
branches;
next	1.53;

1.53
date	2017.07.20.06.35.52;	author root;	state Exp;
branches;
next	1.52;

1.52
date	2017.07.20.05.53.30;	author root;	state Exp;
branches;
next	1.51;

1.51
date	2017.07.20.05.52.37;	author root;	state Exp;
branches;
next	1.50;

1.50
date	2017.07.20.05.51.52;	author root;	state Exp;
branches;
next	1.49;

1.49
date	2017.07.20.05.49.59;	author root;	state Exp;
branches;
next	1.48;

1.48
date	2017.07.20.05.48.04;	author root;	state Exp;
branches;
next	1.47;

1.47
date	2017.07.20.05.46.54;	author root;	state Exp;
branches;
next	1.46;

1.46
date	2017.07.20.05.46.02;	author root;	state Exp;
branches;
next	1.45;

1.45
date	2017.07.20.05.45.15;	author root;	state Exp;
branches;
next	1.44;

1.44
date	2017.07.20.05.20.11;	author root;	state Exp;
branches;
next	1.43;

1.43
date	2017.07.20.05.18.57;	author root;	state Exp;
branches;
next	1.42;

1.42
date	2017.07.20.05.17.08;	author root;	state Exp;
branches;
next	1.41;

1.41
date	2017.07.20.05.15.49;	author root;	state Exp;
branches;
next	1.40;

1.40
date	2017.07.20.05.15.12;	author root;	state Exp;
branches;
next	1.39;

1.39
date	2017.07.20.05.14.33;	author root;	state Exp;
branches;
next	1.38;

1.38
date	2017.07.20.05.13.52;	author root;	state Exp;
branches;
next	1.37;

1.37
date	2017.07.20.05.12.35;	author root;	state Exp;
branches;
next	1.36;

1.36
date	2017.07.20.05.11.24;	author root;	state Exp;
branches;
next	1.35;

1.35
date	2017.07.20.05.09.39;	author root;	state Exp;
branches;
next	1.34;

1.34
date	2017.07.20.05.06.08;	author root;	state Exp;
branches;
next	1.33;

1.33
date	2017.07.20.05.04.52;	author root;	state Exp;
branches;
next	1.32;

1.32
date	2017.07.20.04.58.47;	author root;	state Exp;
branches;
next	1.31;

1.31
date	2017.07.20.04.52.40;	author root;	state Exp;
branches;
next	1.30;

1.30
date	2017.07.20.04.42.40;	author root;	state Exp;
branches;
next	1.29;

1.29
date	2017.07.17.11.12.55;	author root;	state Exp;
branches;
next	1.28;

1.28
date	2017.07.17.11.04.10;	author root;	state Exp;
branches;
next	1.27;

1.27
date	2017.07.15.09.41.31;	author root;	state Exp;
branches;
next	1.26;

1.26
date	2017.07.15.09.38.25;	author root;	state Exp;
branches;
next	1.25;

1.25
date	2017.07.15.09.07.26;	author root;	state Exp;
branches;
next	1.24;

1.24
date	2017.07.15.09.01.50;	author root;	state Exp;
branches;
next	1.23;

1.23
date	2017.07.15.08.42.00;	author root;	state Exp;
branches;
next	1.22;

1.22
date	2017.07.15.08.32.36;	author root;	state Exp;
branches;
next	1.21;

1.21
date	2017.07.15.08.21.42;	author root;	state Exp;
branches;
next	1.20;

1.20
date	2017.07.15.08.17.44;	author root;	state Exp;
branches;
next	1.19;

1.19
date	2017.07.15.08.08.25;	author root;	state Exp;
branches;
next	1.18;

1.18
date	2017.07.15.07.40.22;	author root;	state Exp;
branches;
next	1.17;

1.17
date	2017.07.15.07.33.16;	author root;	state Exp;
branches;
next	1.16;

1.16
date	2017.07.15.07.28.56;	author root;	state Exp;
branches;
next	1.15;

1.15
date	2017.07.15.06.47.29;	author root;	state Exp;
branches;
next	1.14;

1.14
date	2017.07.15.06.17.35;	author root;	state Exp;
branches;
next	1.13;

1.13
date	2017.07.15.05.08.14;	author root;	state Exp;
branches;
next	1.12;

1.12
date	2017.07.15.05.05.20;	author root;	state Exp;
branches;
next	1.11;

1.11
date	2017.07.15.05.02.00;	author root;	state Exp;
branches;
next	1.10;

1.10
date	2017.07.15.04.56.17;	author root;	state Exp;
branches;
next	1.9;

1.9
date	2017.07.15.04.54.23;	author root;	state Exp;
branches;
next	1.8;

1.8
date	2017.07.15.04.51.13;	author root;	state Exp;
branches;
next	1.7;

1.7
date	2017.07.15.04.46.34;	author root;	state Exp;
branches;
next	1.6;

1.6
date	2017.07.15.04.44.55;	author root;	state Exp;
branches;
next	1.5;

1.5
date	2017.07.15.04.39.31;	author root;	state Exp;
branches;
next	1.4;

1.4
date	2017.07.15.04.25.54;	author root;	state Exp;
branches;
next	1.3;

1.3
date	2017.07.15.04.08.00;	author root;	state Exp;
branches;
next	1.2;

1.2
date	2017.07.14.11.45.13;	author root;	state Exp;
branches;
next	1.1;

1.1
date	2017.07.14.09.53.25;	author root;	state Exp;
branches;
next	;


desc
@@


1.60
log
@*** empty log message ***
@
text
@#include "header.h"
// ------------------------------------------------------------------
MODULE_LICENSE("GPL");
MODULE_AUTHOR("SOMNATH");
//------------------------------------------------------------------
Dev *dev;
int major_num = MAJOR_NUM;
int minor_num = MINOR_NUM;
int nod = 0;
// this function is use to take command line argument for insmod command 
// example insmod ./module/lkm_test.ko nod=100
// we are passing value 100 for variable nod
module_param(nod,int,S_IRUGO);
//-----------------------------------------------------------------------
dev_t devid = 0,devno = 0;
static int __init start_func(void)
{
int i = 0;
// before send the device information take a copy of that in your init function
int noreg = NOREG;
int regsize = REGSIZE;
int devsize = DEVSIZE;
int datasize = DATASIZE;
//-----------------------------------------------------------------------------
#ifdef DEBUG
  printk(KERN_INFO "Hellow kernel\n");
#endif  
  // ------------------------------Driver registration---------------------------------------------------
  if(!devid)
  {
  	if( alloc_chrdev_region(&devid,minor_num,nod,DEVICE_NAME)== -1)
    		{
		        #ifdef DEBUG
    			printk(KERN_ERR "Device Reegistration Failed\n");
			#endif
    			goto OUT;
    		}
  }
  else
  {
    if(register_chrdev_region(devid,minor_num,DEVICE_NAME)== -1)
    	{
	        #ifdef DEBUG
	  	printk(KERN_ERR "Device Registration Failed");
		#endif
		goto OUT;
	}
  }
  major_num = MAJOR(devid);
  minor_num = MINOR(devid);
  #ifdef DEBUG
  printk(KERN_INFO "Device Register Successfully with Major Num:-  %d\n",major_num);
  #endif
  //------------------------- END -------------------------------------------------------------------------
  
  //------------------------ GETTING MEMORY TO SCULL DEVICES ----------------------------------------------
  dev = (Dev *)kmalloc((sizeof(Dev)*nod),GFP_KERNEL);
 if(!dev)
 {
     #ifdef DEBUG
     printk(KERN_ERR "Kmalloc failed\n");
     #endif
     goto OUT;

  }
  else
  {
   #ifdef DEBUG
   printk(KERN_INFO "Memory Allocated successfully for scull devices\n");
   #endif
  }
   memset(dev,'\0',sizeof(Dev)*nod);
//  mymodule();
  for(i=0;i<nod;i++)
  {
          dev[i].noreg=noreg;
	  dev[i].regsize=regsize;
	  dev[i].devsize=devsize;
          dev[i].datasize=datasize;
 	  dev[i].c_dev.ops = &fops;
  	  cdev_init(&dev[i].c_dev,dev[i].c_dev.ops);
 	 devno = MKDEV(major_num,i);
	 if(cdev_add(&dev[i].c_dev,devno,i)== -1)
 		{
		 #ifdef DEBUG
       		  printk(KERN_ERR "cdev_add error");
		 #endif
		 goto OUT;
		}  
	else
	{
 	#ifdef DEBUG
	//  printk(KERN_INFO "Minor num - %d\n",MINOR(devno));
	   printk(KERN_INFO "Minor num - %d\n",MINOR(dev[i].c_dev.dev));
	 #endif 
	}  
 } 
  return 0;

OUT:
 	return -1;
}

module_init(start_func);
@


1.59
log
@*** empty log message ***
@
text
@d60 1
d62 1
d68 1
d70 1
@


1.58
log
@*** empty log message ***
@
text
@d19 6
d72 4
@


1.57
log
@*** empty log message ***
@
text
@d10 3
d14 1
@


1.56
log
@*** empty log message ***
@
text
@d9 2
a10 1
int nod = 5;
@


1.55
log
@*** empty log message ***
@
text
@d74 2
a75 1
	  printk(KERN_INFO "Minor num - %d\n",MINOR(devno));
@


1.54
log
@*** empty log message ***
@
text
@d59 1
a59 1
  for(i=0;i<nod,i++)
d64 1
a64 1
	 if(cdev_add(&dev[i]c_dev,devno,i)== -1)
@


1.53
log
@*** empty log message ***
@
text
@d9 1
a9 1
int nod = NOD;
d13 1
d59 17
a75 9
   dev->c_dev.ops = &fops;
  cdev_init(&dev->c_dev,dev->c_dev.ops);
  devno = MKDEV(major_num,1);
 if(cdev_add(&dev->c_dev,devno,1)== -1)
 	{
	 #ifdef DEBUG
         printk(KERN_ERR "cdev_add error");
	 #endif
	 goto OUT;
d77 1
a77 6
else
{
 #ifdef DEBUG
  printk(KERN_INFO "Minor num - %d\n",MINOR(devno));
 #endif 
}  
@


1.52
log
@*** empty log message ***
@
text
@d13 1
d15 1
d21 1
d23 1
d31 1
d33 1
d39 1
d41 1
d63 1
d65 1
d70 1
d72 1
@


1.51
log
@*** empty log message ***
@
text
@d6 1
a6 1
extern Dev *dev;
@


1.50
log
@*** empty log message ***
@
text
@d6 1
a6 1
Dev *dev;
@


1.49
log
@*** empty log message ***
@
text
@d60 1
a60 2
 minor_num = MINOR(devno);
  printk(KERN_INFO "Minor num - %d\n" minor_num);
@


1.48
log
@*** empty log message ***
@
text
@d59 4
a62 1
  printk(KERN_INFO "Minor num - %d\n" MINOR(devno));
@


1.47
log
@*** empty log message ***
@
text
@d52 1
a52 1
  devno = MKNOD(major_num,1);
@


1.46
log
@*** empty log message ***
@
text
@d59 1
a59 1
  printk(KERN_INFO "Minor num - %d"MINOR(devno));
@


1.45
log
@*** empty log message ***
@
text
@d52 1
a52 1
  devno = MKNOD(major_num,1)
@


1.44
log
@*** empty log message ***
@
text
@d10 1
a10 1
dev_t devid = 0;
d31 3
a33 1
  printk(KERN_INFO "Device Register Successfully with Major Num:-  %d \t %d\n",MAJOR(devid),MINOR(devid));
a37 5
 
 //--------------------------------- C_DEV_INITIALIZE------------------------------------------------------
   dev->c_dev.ops = &fops;
  cdev_init(&dev->c_dev,dev->c_dev.ops);
 
d50 10
@


1.43
log
@*** empty log message ***
@
text
@a5 1
//static struct file_operations fops={};
@


1.42
log
@*** empty log message ***
@
text
@d6 1
a6 1
static struct file_operations fops={};
@


1.41
log
@*** empty log message ***
@
text
@d40 1
a40 1
  cdev_init(dev->c_dev,dev->c_dev.ops);
@


1.40
log
@*** empty log message ***
@
text
@d40 1
a40 1
  cdev_init(&dev->c_dev,&dev->c_dev.ops);
@


1.39
log
@*** empty log message ***
@
text
@d40 1
a40 1
//  cdev_init(&Dev->c_dev,&Dev->c_dev.ops);
@


1.38
log
@*** empty log message ***
@
text
@d52 1
a52 1
   memset(ret,'\0',sizeof(Dev)*nod);
@


1.37
log
@*** empty log message ***
@
text
@d7 1
a7 1
Dev *ret;
d36 1
a36 1
  ret = (Dev *)kmalloc((sizeof(Dev)*nod),GFP_KERNEL);
d39 1
a39 1
   ret->c_dev.ops = &fops;
d42 1
a42 1
 if(!ret)
@


1.36
log
@*** empty log message ***
@
text
@d39 1
a39 1
   Dev.c_dev.ops = &fops;
@


1.35
log
@*** empty log message ***
@
text
@d39 1
a39 1
   Dev->c_dev.ops = &fops;
@


1.34
log
@*** empty log message ***
@
text
@d6 1
@


1.33
log
@*** empty log message ***
@
text
@d39 1
a39 1
  cdev_init(&Dev->c_dev,&Dev->c_dev.ops);
@


1.32
log
@*** empty log message ***
@
text
@d35 1
a35 1
  ret = kmalloc((sizeof(Dev)*nod),GFP_KERNEL);
d38 2
a39 1
  cdev_init(&Dev->c_dev,&fops);
@


1.31
log
@*** empty log message ***
@
text
@d38 1
a38 1
  cdev_init(Dev->c_dev,&fops);
@


1.30
log
@*** empty log message ***
@
text
@d38 1
a38 1
 
@


1.29
log
@*** empty log message ***
@
text
@d13 1
a13 1
  printk(KERN_INFO "HHHHHHHHHHHHHHHHhHellow kernel\n");
d36 3
@


1.28
log
@*** empty log message ***
@
text
@d47 1
a47 1

@


1.27
log
@*** empty log message ***
@
text
@d6 1
a6 1

d35 4
a38 2
  if(!kmalloc((sizeof(Dev)*nod),GFP_KERNEL))
  {
d48 1
a48 1
  mymodule();
@


1.26
log
@*** empty log message ***
@
text
@a1 1
//#include "declaration.h"
@


1.25
log
@*** empty log message ***
@
text
@d46 2
a47 3
	printk (KERN_INFO "CALLING MYMODULE\n");
//  mymodule();
	printk (KERN_INFO "CALLed MYMODULE\n");
@


1.24
log
@*** empty log message ***
@
text
@d2 1
a2 1
#include "declaration.h"
d47 1
a47 1
  mymodule();
@


1.23
log
@*** empty log message ***
@
text
@d14 1
a14 1
  printk(KERN_INFO "Hellow kernel\n");
@


1.22
log
@*** empty log message ***
@
text
@d2 1
a2 1
void mymodule(void);
@


1.21
log
@*** empty log message ***
@
text
@d46 1
a46 1

d48 1
@


1.20
log
@*** empty log message ***
@
text
@d2 1
a2 1

@


1.19
log
@*** empty log message ***
@
text
@d47 1
a47 1
   mymodule();
@


1.18
log
@*** empty log message ***
@
text
@d47 1
@


1.17
log
@*** empty log message ***
@
text
@d36 1
a36 1
  if(!kmalloc((sizeof(Dev)*nod),0))
d38 1
a38 1
     printk(KERN_ERR "Kmalloc failed");
d44 1
a44 1
   printk(KERN_INFO "Memory Allocated successfully for scull devices");
@


1.16
log
@*** empty log message ***
@
text
@d36 1
a36 1
  if(!kmalloc(sizeof(Dev)*nod))
@


1.15
log
@*** empty log message ***
@
text
@d15 1
a15 1
  // ----------------Driver registration---------------------- 
d33 14
@


1.14
log
@*** empty log message ***
@
text
@d16 11
a26 1
  if( alloc_chrdev_region(&devid,minor_num,nod,DEVICE_NAME)== -1)
d28 4
a31 4
    		printk(KERN_ERR "Device Reegistration Failed\n");
    		goto OUT;
    	}
	
@


1.13
log
@*** empty log message ***
@
text
@d8 4
a11 2
int major_num = 0;
static struct file_operations fops={};
d16 7
a22 9
  major_num = register_chrdev(major_num,DEVICE_NAME,&fops);

if(major_num == -1)
    {
    printk(KERN_ERR "Device Reegistration Failed\n");
    goto OUT;
    }
  else 
  	printk(KERN_INFO "Device Register Successfully with Major Num:-  %d\n",major_num);
@


1.12
log
@*** empty log message ***
@
text
@d9 1
a9 1
//static struct file_operations fops={};
@


1.11
log
@*** empty log message ***
@
text
@d9 1
a9 1
static struct file_operations fops={};
@


1.10
log
@*** empty log message ***
@
text
@d15 2
a16 1
  if(major_num == -1)
@


1.9
log
@*** empty log message ***
@
text
@d9 1
a9 1
static struct file_operations fops;
@


1.8
log
@*** empty log message ***
@
text
@d9 1
a9 1
//static struct file_operations fops;
@


1.7
log
@*** empty log message ***
@
text
@d9 1
a9 1
static struct file_operations fops;
@


1.6
log
@*** empty log message ***
@
text
@d17 1
a17 1
    printk(KERN_ERR "Device Reegistration Failed");
d21 1
a21 1
  	printk(KERN_INFO "Device Register Successfully with Major Num:-  %d ",major_num);
@


1.5
log
@*** empty log message ***
@
text
@d14 3
a16 2
  if(register_chrdev(major_num,DEVICE_NAME,&fops)==-1)
  {
d19 2
a20 2
  }
  else
@


1.4
log
@*** empty log message ***
@
text
@d9 1
a9 1
const struct file_operations fops;
d14 1
a14 1
  if(register_chrdev(major_num,DEVICE_NAME,fops)==-1)
@


1.3
log
@*** empty log message ***
@
text
@d9 1
a9 1
struct file_operations *fops;
d14 1
a14 1
  if(register_chrdev(major_num,DEVICE_NAME,*fops)==-1)
@


1.2
log
@*** empty log message ***
@
text
@d7 3
a9 2
//
//
d13 8
d22 3
@


1.1
log
@Initial revision
@
text
@d3 6
@
